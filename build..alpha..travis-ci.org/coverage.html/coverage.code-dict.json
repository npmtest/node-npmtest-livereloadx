{"/home/travis/build/npmtest/node-npmtest-livereloadx/test.js":"/* istanbul instrument in package npmtest_livereloadx */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-livereloadx/lib.npmtest_livereloadx.js":"/* istanbul instrument in package npmtest_livereloadx */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_livereloadx = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_livereloadx = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-livereloadx/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-livereloadx && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_livereloadx */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_livereloadx\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_livereloadx.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_livereloadx.rollup.js'] =\n            local.assetsDict['/assets.npmtest_livereloadx.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_livereloadx.__dirname + '/lib.npmtest_livereloadx.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-livereloadx/node_modules/livereloadx/lib/index.js":"\"use strict\";\n\nmodule.exports = require('./server').createServer;\n","/home/travis/build/npmtest/node-npmtest-livereloadx/node_modules/livereloadx/lib/server.js":"\"use strict\";\n\nvar fs = require('fs')\n  , http = require('http')\n  , log = require('./log')('server')\n  , ProxyHandler = require('./proxy')\n  , send = require('send')\n  , StaticHandler = require('./static')\n  , url = require('url')\n  , Watcher = require('./watcher')\n  , WebSocketHandler = require('./websocket');\n\n\n// Static file '/livereload.js' handler\nfunction LiveReloadJsHandler() {\n}\n\nLiveReloadJsHandler.prototype = {\n  handle: function(req, res) {\n    var path = url.parse(req.url).pathname;\n\n    // path should be /livereload.js\n    if (path !== \"/livereload.js\") {\n      return false;\n    }\n\n    // send /livereload.js\n    send(req, path, {root: __dirname + '/../contrib/'})\n      .pipe(res);\n    return true;\n  }\n};\n\nexports.LiveReloadJsHandler = LiveReloadJsHandler;\n\n\n// Add logging for requests\n// (ref) connect/lib/middleware/logger.js\nfunction addLogger(req, res) {\n  function remoteAddr(req) {\n    if (req.ip) { return req.ip; }\n    var sock = req.socket;\n    if (sock.socket) { return sock.socket.remoteAddress; }\n    return sock.remoteAddress;\n  }\n\n  var end = res.end;\n  res.end = function(chunk, encoding){\n    res.end = end;\n    res.end(chunk, encoding);\n\n    log.info('%s - \"%s %s HTTP/%d.%d\" %s %s',\n      remoteAddr(req), req.method, req.originalUrl || req.url,\n      req.httpVersionMajor, req.httpVersionMinor,\n      res.statusCode,\n      res._headers && res._headers['content-length'] || '-');\n  };\n}\n\n\nfunction Server(config, watcher) {\n  this.config = require('./config').setDefaultValue(config);\n  this.is_included = require('./filter').getMatcher(this.config.filter);\n  this.watcher = watcher || new Watcher();\n}\n\nServer.prototype = {\n  listen: function() {\n    var self = this;\n\n    // setup handlers\n    var handlers = [ new LiveReloadJsHandler() ];\n    if (this.config.proxy) {\n      handlers.push(new ProxyHandler(this.config));\n    } else if (this.config.static) {\n      handlers.push(new StaticHandler(this.config));\n    }\n\n    var server = http.createServer(function(request, response) {\n      addLogger(request, response);\n\n      for (var i = 0; i < handlers.length; i++) {\n        if (handlers[i].handle(request, response)) {\n          return;\n        }\n      }\n      response.writeHead(404);\n      response.write(\"File not found\");\n      response.end();\n      log.debug(\"404 %s\", request.url);\n    }).listen(this.config.port);\n\n    this.webSocket = new WebSocketHandler(this.config, { server: server });\n\n    log.info(\"Waiting on port %d...\", this.config.port);\n    return this;\n  },\n\n  notifyFileChange: function(file) {\n    var msg = JSON.stringify({\n      command: 'reload',\n      path: file,\n      liveCSS: this.config.liveCSS,\n      liveImg: this.config.liveImg\n    });\n\n    if (this.webSocket) {\n      this.webSocket.send(file, msg);\n    }\n  },\n\n  watch: function() {\n    this.watcher.watch(this.config.dir, this.is_included);\n\n    var self = this;\n    this.watcher.on('change', function(file) {\n      if (self.is_included(file)) {\n        if (self.config.delay === 0) {\n          self.notifyFileChange(file);\n        } else {\n          log.info('delay', self.config.delay);\n          setTimeout(self.notifyFileChange.bind(self), self.config.delay, file);\n        }\n      } else {\n        log.info('skip: %s', file);\n      }\n    });\n    return this;\n  }\n};\n\nexports.Server = Server;\n\n\nexports.createServer = function(config) {\n  log.debug(\"createServer\", config);\n  var server = new Server(config || {});\n  return server;\n};\n","/home/travis/build/npmtest/node-npmtest-livereloadx/node_modules/livereloadx/lib/log.js":"\"use strict\";\n\nvar util = require('util');\n\n// Logger constructor\nfunction Logger(transport) {\n  this.transport = transport;\n}\n\n// Core logging method\nLogger.prototype.log = function(level, args) {\n  this.transport.apply(this.transport, arguments);\n};\n\n//  Define prototype methods for each log level\n//  e.g. logger.log('info', msg) <=> logger.info(msg)\n['error', 'warn', 'info', 'debug', 'trace'].forEach(function(level) {\n  Logger.prototype[level] = function(args) {\n    args = Array.prototype.slice.call(arguments);\n    args.unshift(level);\n    this.log.apply(this, args);\n  };\n});\n\n\n// winston compatible transport\nfunction createConsoleTransport(name) {\n  var esc = String.fromCharCode(0x1b);\n  var levelMap = {\n    'error': esc + '[31merror' + esc + '[39m: ', // red\n    'warn':  esc + '[33mwarn'  + esc + '[39m:  ', // yellow\n    'info':  esc + '[32minfo'  + esc + '[39m:  ', // green\n    'debug': esc + '[34mdebug' + esc + '[39m: ', // white\n    'trace': esc + '[36mtrace' + esc + '[39m: ' // blue\n  };\n\n  function getNowString() {\n    function pad2(n) {\n      return n < 10 ? \"0\" + n : n.toString();\n    }\n\n    var d = new Date();\n    return util.format('%s-%s-%s %s:%s:%s',\n      d.getFullYear(), pad2(d.getMonth() + 1), pad2(d.getDate()),\n      pad2(d.getHours()), pad2(d.getMinutes()), pad2(d.getSeconds()));\n  }\n\n  return function() {\n    var args = Array.prototype.slice.call(arguments);\n\n    // level filter\n    var level = args.shift();\n    if (level === 'trace') {\n      return;\n    }\n    if (!module.exports.verbose && level === 'debug') {\n      return;\n    }\n\n    // add time and colorize level\n    args[0] = (getNowString()) + ' - ' + levelMap[level] + args[0];\n\n    console.log.apply(console, args);\n  };\n}\n\n// debug.js transport\nfunction createDebugTransport(name) {\n  var debug = require('debug')('livereloadx:' + name);\n  return function(level, args) {\n    args = Array.prototype.slice.call(arguments);\n    args.shift();\n    debug.apply(debug, args);\n  };\n}\n\n// debug compatible interface\nmodule.exports = function(name) {\n  var transport = null;\n  if (module.exports.cli) {\n    transport = createConsoleTransport(name);\n  } else {\n    transport = createDebugTransport(name);\n  }\n  return new Logger(transport);\n};\n\nmodule.exports.cli = false;\n","/home/travis/build/npmtest/node-npmtest-livereloadx/node_modules/livereloadx/lib/proxy.js":"\"use strict\";\n\nvar httpProxy = require('http-proxy')\n  , inject = require('./html').inject\n  , zlib = require('zlib')\n  , log = require('./log')('proxy')\n  , ServerResponse = require('http').ServerResponse\n  , StaticHandler = require('./static')\n  , url = require('url');\n\n// inspired by webxl/grunt-reload/tasks/reload.js\nfunction ServerResponseWrapper(req, res, port) {\n  this.req = req;\n  this.res = res;\n  this.port = port;\n\n  this.origWriteHead = res.writeHead;\n  this.origWrite = res.write;\n  this.origEnd = res.end;\n  res.writeHead = this.writeHead.bind(this);\n  res.write = this.write.bind(this);\n  res.end = this.end.bind(this);\n}\n\nServerResponseWrapper.prototype.writeHead = function(statusCode, headers) {\n  this.statusCode = statusCode;\n  this.headers = headers;\n\n  log.debug(\"%s: status=%d, header=\", this.req.url, statusCode, headers);\n  var isHtml = /html/.test(headers['content-type']);\n  log.debug('%s: isHtml=%d', this.req.url, isHtml);\n  if (isHtml) {\n    log.debug(\"%s: start injecting\", this.req.url);\n    this.injecting = true;\n    this.tmpBuffer = [];\n  } else {\n    log.debug(\"%s: not injected\", this.req.url);\n    this.injecting = false;\n\n    // setHeader() for logging Content-Length in server.js\n    if (headers && headers['content-length']) {\n      this.res.setHeader('Content-Length', headers['content-length']);\n    }\n\n    this.origWriteHead.call(this.res, statusCode, headers);\n  }\n};\n\nServerResponseWrapper.prototype.write = function(chunk, encoding) {\n  if (this.injecting) {\n    log.debug(\"%s: add to tmpBuffer\", this.req.url);\n    this.tmpBuffer.push(new Buffer(chunk, encoding));\n  } else {\n    log.debug(\"%s: call original write\", this.req.url);\n    this.origWrite.call(this.res, chunk, encoding);\n  }\n},\n\nServerResponseWrapper.prototype.end = function(chunk, encoding) {\n  if (!this.injecting) {\n    log.debug('%s: call original end', this.req.url, chunk, encoding);\n    this.origEnd.call(this.res, chunk, encoding);\n    return;\n  }\n\n  // get remote response body\n  if (chunk) { this.write(chunk, encoding); }\n  var buffer = Buffer.concat(this.tmpBuffer);\n\n  if (/^(gzip|deflate)$/.test(this.headers['content-encoding'])) {\n    // It's compressed.\n    log.debug('%s: end() called. decompress buffer', this.req.url);\n    var self = this;\n    this.decompress(buffer, function(err, buf) {\n      if (err) {\n        log.error('%s: error on decompressing: ', self.req.url, err);\n        self.finish(buffer);\n      } else {\n        log.debug('%s: decompress finished. inject snippet', self.req.url);\n        delete self.headers['content-encoding'];\n        self.finish(self.getSnippetInjectedBuffer(buf));\n      }\n    });\n  } else {\n    // Modify response and returns it to client\n    log.debug('%s: end() called. inject snippet', this.req.url);\n    this.finish(this.getSnippetInjectedBuffer(buffer));\n  }\n};\n\nServerResponseWrapper.prototype.decompress = function(buffer, callback) {\n  if (this.headers['content-encoding'] === 'gzip') {\n    zlib.gunzip(buffer, callback);\n  } else if (this.headers['content-encoding'] === 'deflate') {\n    zlib.inflate(buffer, callback);\n  } else {\n    throw new Error('Invalid encoding: ' + this.headers['content-encoding']);\n  }\n};\n\nServerResponseWrapper.prototype.getSnippetInjectedBuffer = function(oldBuf) {\n  // inject html\n  var newBuf = inject(oldBuf, this.port);\n\n  log.debug('%s: content-length changed: %d -> %d', this.req.url,\n    oldBuf.length, newBuf.length);\n  return newBuf;\n};\n\nServerResponseWrapper.prototype.finish = function(buffer) {\n  // set Content-Length header\n  // `res.setHeader()` is necessary for logging Content-Length in server.js\n  this.headers['content-length'] = buffer.length.toString();\n  this.res.setHeader('Content-Length', buffer.length.toString());\n\n  log.debug('%s: finish', this.req.url);\n  log.debug('  - header: ', this.headers);\n  this.origWriteHead.call(this.res, this.statusCode, this.headers);\n  this.origWrite.call(this.res, buffer);\n  this.origEnd.call(this.res);\n};\n\nfunction wrapResponse(req, res, port) {\n  new ServerResponseWrapper(req, res, port);\n}\n\nfunction rewriteLocation(host, location, proxy) {\n\n    // use target rather than source, because rewrite to http from https has been done already.\n    // see ... https://github.com/nodejitsu/node-http-proxy/blob/v0.8.7/lib/node-http-proxy/http-proxy.js#L255\n    var scheme = proxy.source.https ? 'https://' : 'http://';\n    var fromList = [scheme + proxy.target.host + ':' + proxy.target.port + '/'];\n    var rewriteTo = host ? scheme + host : \"\";\n\n    if (proxy.source.https) {\n        if (+proxy.target.port === 443) {\n            fromList.push(scheme + proxy.target.host + '/');\n        }\n    } else {\n        if (+proxy.target.port === 80) {\n            fromList.push(scheme + proxy.target.host + '/');\n        }\n    }\n\n    fromList.some(function(from){\n        if (location.lastIndexOf(from, 0) === 0) {\n            location = rewriteTo + location.substring(from.length - 1);\n            return true;\n        }\n    });\n\n    return location;\n}\n\nfunction wrapRewriteLocation(req, res, proxy) {\n  var host = req.headers.host;\n  var writeHead = res.writeHead;\n  res.writeHead = function(statusCode, headers) {\n    if (((statusCode === 301) || (statusCode === 302)) && headers.location) {\n      headers.location = rewriteLocation(host, headers.location, proxy);\n    }\n    return writeHead.call(this, statusCode, headers);\n  };\n}\n\nfunction ProxyHandler(config) {\n  this.config = config;\n  this.init();\n}\n\nProxyHandler.prototype.init = function() {\n  log.debug('proxy: ', this.config.proxy);\n  if (this.config.proxy === '') {\n    return;\n  }\n\n  var proxyUrl = url.parse(this.config.proxy);\n  if (!proxyUrl.protocol) {\n    throw new Error(\"proxy URL protocol is not specified:\" + this.config.proxy);\n  }\n\n  // create HttpProxy instance\n  var isHttps = (proxyUrl.protocol === 'https:');\n  var port = proxyUrl.port || (isHttps ? 443 : 80);\n  if (!isHttps && proxyUrl.protocol !== 'http:') {\n    throw new Error(\"proxy URL protocol is invalid: \" + this.config.proxy);\n  }\n  if (proxyUrl.path !== '/') {\n    log.warn(\"proxy URL path '%s' is ignored\", proxyUrl.path);\n  }\n  this.proxy = new httpProxy.HttpProxy({\n    target: {\n      host: proxyUrl.hostname,\n      port: port,\n      https: isHttps\n    },\n    enable: {\n      xforward: false\n    },\n    changeOrigin: true\n  });\n\n  // create StaticHandler instance if prefer-local is enabled\n  if (this.config.preferLocal) {\n    this.staticHandler = new StaticHandler(this.config, this.onError.bind(this));\n  }\n\n  log.info(\"Enabled proxy mode. (proxy to '%s//%s:%d/')\", proxyUrl.protocol, \n    proxyUrl.hostname, port);\n};\n\nProxyHandler.prototype.handle = function(req, res) {\n  if (!this.proxy) {\n    return false;\n  }\n\n  if (this.staticHandler) {\n    if (this.staticHandler.handle(req, res)) {\n      return true;\n    }\n  }\n\n  this.doProxy(req, res);\n  return true;\n};\n\nProxyHandler.prototype.doProxy = function(req, res) {\n  // rewrite location header\n  wrapRewriteLocation(req, res, this.proxy);\n\n  // hook response\n  wrapResponse(req, res, this.config.port);\n\n  // pass to http-proxy\n  log.debug(\"process: %s\", req.url);\n  this.proxy.proxyRequest(req, res);\n  return true;\n};\n\nProxyHandler.prototype.onError = function(req, res, err) {\n  if (err.status === 404) {\n    // If file not found on local dir, retrieve from remote server\n    log.debug(\"%s: not found on local. load from remote.\", req.url);\n    this.doProxy(req, res);\n  } else {\n    // unknown error\n    // (ref) connect/lib/proto.js\n\n    // default to 500\n    if (res.statusCode < 400) { res.statusCode = 500; }\n\n    // respect err.status\n    if (err.status) { res.statusCode = err.status; }\n\n    // gets a basic error message\n    var msg = err.stack || err.toString();\n    log.error('Failed to read from local: %s, %s', this.req.url, msg);\n\n    if (res.headerSent) { return req.socket.destroy(); }\n    res.setHeader('Content-Type', 'text/plain');\n    res.setHeader('Content-Length', Buffer.byteLength(msg));\n    if ('HEAD' === req.method) { return res.end(); }\n    res.end(msg);\n  }\n};\n\nmodule.exports = ProxyHandler;\n","/home/travis/build/npmtest/node-npmtest-livereloadx/node_modules/livereloadx/lib/html.js":"\"use strict\";\n\nvar log = require('./log')('html');\n\n// Search '</body>' case insensitvely from given Buffer.\nfunction bufLastSearchBody(buffer) {\n  // BM method map\n  var map = {};\n  map['<'.charCodeAt(0)] = 0;\n  map['/'.charCodeAt(0)] = 1;\n  map['b'.charCodeAt(0)] = map['B'.charCodeAt(0)] = 2;\n  map['o'.charCodeAt(0)] = map['O'.charCodeAt(0)] = 3;\n  map['d'.charCodeAt(0)] = map['D'.charCodeAt(0)] = 4;\n  map['y'.charCodeAt(0)] = map['Y'.charCodeAt(0)] = 5;\n  map['>'.charCodeAt(0)] = 6;\n\n  var skip = 0\n    , bodyLen = '</body>'.length;\n\n  for (var i = buffer.length - bodyLen; i >= 0; i -= skip) {\n    for (var j = 0; j < bodyLen; j++) {\n      if (map[buffer[i + j]] !== j) {\n        break;\n      }\n    }\n    if (j === bodyLen) {\n      return i;\n    }\n    skip = map[buffer[i]] > 0 ? map[buffer[i]] : bodyLen;\n  }\n  return -1;\n}\n\nvar inject = exports.inject = function(buffer, port) {\n  // create snippet code\n  var snippet = \"<script>document.write('<script src=\\\"http://' + (location.host || 'localhost').split(':')[0] + ':\" +\n      port + \"/livereload.js?snipver=2&port=\" + port + \"\\\"></' + 'script>')</script>\";\n\n  // find embed position\n  var pos = bufLastSearchBody(buffer);\n\n  var ret = new Buffer(buffer.length + snippet.length);\n  if (pos >= 0) {\n    log.debug('insert snippet at %d', pos);\n    buffer.copy(ret, 0, 0, pos);\n    ret.write(snippet, pos);\n    buffer.copy(ret, pos + snippet.length, pos);\n  } else {\n    log.debug('append snippet');\n    buffer.copy(ret);\n    ret.write(snippet, buffer.length);\n  }\n\n  return ret;\n};\n","/home/travis/build/npmtest/node-npmtest-livereloadx/node_modules/livereloadx/lib/static.js":"\"use strict\";\n\nvar EventEmitter = require('events').EventEmitter\n  , fs = require('fs')\n  , inject = require('./html').inject\n  , log = require('./log')('static')\n  , pause = require('pause')\n  , send = require('send')\n  , url = require('url')\n  , util = require('util');\n\n\n// Static file handler\n//   onError: error callback (when an error occur, this callback is called and\n//            should call res.end())\nfunction StaticHandler(config, onError) {\n  this.config = config;\n  this.onError = onError;\n  this.root = require('path').resolve(this.config.dir);\n\n  if (this.config.static) {\n    log.info(\"Enabled static mode.\");\n  }\n  log.debug('root dir: %s', this.root);\n\n  EventEmitter.call(this);\n}\n\n// inherits from EventEmitter\nutil.inherits(StaticHandler, EventEmitter);\n\n// Handle request\nStaticHandler.prototype.handle = function(req, res) {\n  if ('GET' !== req.method && 'HEAD' !== req.method) { return false; }\n\n  var path = url.parse(req.url).pathname;\n  var _pause = pause(req);\n  var self = this;\n\n  log.debug('path: %s', path);\n  var sendStream = send(req, path, {root: this.root});\n\n  if (path.match(/(\\/|\\.html?)$/)) {\n    // hook SendStream.send()\n    sendStream.send = function(path, stat) {\n      // HTML -> call sendWithInjection()\n      self.sendWithInjection(path, stat, this);\n    };\n  }\n\n  // Set error callback\n  if (this.onError) {\n    sendStream.on('error', function(err) {\n      self.onError(req, res, err);\n\n      // replay end & data events\n      // (ref) connect/lib/middlewares/static.js\n      //       https://gist.github.com/mikedeboer/3047099\n      _pause.resume();\n    });\n  }\n\n  sendStream\n    .on('end', function() { log.debug('end'); self.emit('end'); })\n    .pipe(res);\n  return true;\n};\n\n\n// Inserts LiveReload snippet and returns to client\nStaticHandler.prototype.sendWithInjection = function(path, stat, stream) {\n  // read file to end\n  var self = this;\n  fs.readFile(path, function(err, data) {\n    if (err) {\n      stream.error(500, err);\n      return;\n    }\n\n    // set header\n    stream.setHeader(path, stat);\n    stream.res.setHeader('Content-Type', 'text/html');\n\n    // inject snippet\n    var buffer = inject(data, self.config.port);\n\n    // write to stream\n    stream.res.setHeader('Content-Length', buffer.length);\n    stream.res.write(buffer);\n    stream.res.end();\n  });\n};\n\nmodule.exports = StaticHandler;\n","/home/travis/build/npmtest/node-npmtest-livereloadx/node_modules/livereloadx/lib/watcher.js":"\"use strict\";\n\nvar fsmonitor = require('fsmonitor')\n  , log = require('./log')('watcher')\n  , util = require('util')\n  , EventEmitter = require('events').EventEmitter;\n\nfunction Watcher() {\n  EventEmitter.call(this);\n}\nutil.inherits(Watcher, EventEmitter);\n\nWatcher.prototype.watch = function(dir, is_included) {\n  var self = this;\n\n  var filter = {\n    matches: function() { return true; },\n    excludes: function(path) {\n      path = path.replace(/\\\\/g, '/') + '/';\n      if (is_included(path)) {\n        log.debug(\"  watching '%s'\", path);\n        return false;\n      } else {\n        log.debug(\"  skipping '%s'\", path);\n        return true;\n      }\n    }\n  };\n\n  var watcher = fsmonitor.watch(dir, filter, function(change) {\n    log.debug(\"Change %s\", change);\n    change.modifiedFiles.concat(change.addedFiles).forEach(function(file) {\n      self.emit(\"change\", file.replace(/\\\\/g, '/'));\n    });\n  });\n\n  log.info('Watching \"%s\"...', require('path').resolve(dir));\n  return watcher;\n};\n\nmodule.exports = Watcher;\n","/home/travis/build/npmtest/node-npmtest-livereloadx/node_modules/livereloadx/lib/websocket.js":"\"use strict\";\n\nvar log = require('./log')('websocket')\n  , WebSocketServer = require('ws').Server;\n\n\n// WebSocket server\nfunction WebSocketHandler(config, options) {\n  this.config = config;\n  this.clients = [];\n\n  this.wsServer = new WebSocketServer(options);\n  this.wsServer.on('connection', this.onConnection.bind(this));\n}\n\nWebSocketHandler.prototype = {\n  send: function(file, msg) {\n    log.info(\"notify: %s (%d client)\", file, this.clients.length, \n      this.clients.length > 2 ? 's' : '');\n    this.clients.forEach(function(socket) {\n      socket.send(msg);\n    });\n  },\n\n  close: function() {\n    this.wsServer.close();\n  },\n\n  onConnection: function(socket) {\n    log.debug(\"on connection\");\n    var remoteAddress = \"(unknown)\";\n    var self = this;\n\n    if (socket._socket) {\n      remoteAddress = socket._socket.remoteAddress;\n    }\n    log.info(\"%s - new connection to websocket server\", remoteAddress);\n\n    this.clients.push(socket);\n\n    socket.on('message', function(message) {\n      self.onMessage(socket, message);\n    });\n    socket.on('close', function() {\n      self.onClose(socket, remoteAddress);\n    });\n  },\n\n  onMessage: function(socket, message) {\n    log.debug(\"on message: %s\", message);\n    var msg = JSON.parse(message);\n    if (msg.command === 'hello') {\n      socket.send(JSON.stringify({\n        command: 'hello',\n        protocols: [\n          'http://livereload.com/protocols/official-7'\n        ],\n        serverName: 'livereloadx'\n      }));\n    }\n  },\n\n  onClose: function(socket, remoteAddress) {\n    log.debug(\"on close\");\n    log.info(\"%s - websocket connection closed\", remoteAddress);\n\n    var i = this.clients.indexOf(socket);\n    if (i >= 0) {\n      this.clients.splice(i, 1);\n    }\n  }\n};\n\nmodule.exports = WebSocketHandler;\n","/home/travis/build/npmtest/node-npmtest-livereloadx/node_modules/livereloadx/bin/livereloadx.js":"#!/usr/bin/env node\n\nrequire('../lib/cli').run();\n","/home/travis/build/npmtest/node-npmtest-livereloadx/node_modules/livereloadx/lib/cli.js":"\"use strict\";\n\nexports.run = function() {\n  // enable CLI mode\n  require('./log').cli = true;\n  var log = require('./log')('cli');\n\n  // parse argv\n  var config;\n  try {\n    config = require('./config').parseArgv(process.argv);\n  } catch (e) {\n    log.error(e.message || e);\n    return;\n  }\n\n  // enable verbose output\n  if (config.verbose) {\n    require('./log').verbose = true;\n  }\n\n  // dump config\n  require('./config').dump(log.info.bind(log), config);\n\n  var server = require('./server').createServer(config);\n  server.listen().watch();\n};\n","/home/travis/build/npmtest/node-npmtest-livereloadx/node_modules/livereloadx/lib/config.js":"\"use strict\";\n\nvar program = require('commander')\n  , fs = require('fs');\n\nvar defaultValues = {\n  cli: false,\n  dir: './',\n  filter: [\n    {type: 'exclude', pattern: '.{git,svn}/'},\n    {type: 'include', pattern: '*/'},\n    {type: 'include', pattern: '*.{html,shtml,tmpl,xml,css,js,json,jpeg,jpg,gif,png,ico,cgi,php,py,pl,pm,rb}'},\n    {type: 'exclude', pattern: '*'}\n  ],\n  static: false,\n  port: 35729,\n  preferLocal: false,\n  proxy: '',\n  delay: 0,\n  verbose: false,\n  liveCSS: true,\n  liveImg: true\n};\n\nprogram\n  .version(JSON.parse(fs.readFileSync(__dirname + '/../package.json', 'utf8')).version)\n  .usage('[options] [dir]')\n  .option('--exclude <pattern>', 'exclude file matching pattern')\n  .option('--include <pattern>', 'don\\'t exclude file matching pattern')\n  .option('-p, --port <port>', 'change wait port', function(val){ return parseInt(val, 10); })\n  .option('-l, --prefer-local', 'return a local file if it exists (proxy mode only)')\n  .option('-s, --static', 'enable static server mode')\n  .option('-v, --verbose', 'enable verbose log')\n  .option('-y, --proxy <url>', 'enable proxy server mode')\n  .option('-d, --delay <milliseconds>', 'add a delay in milliseconds', function(val){ return parseInt(val, 10); })\n  .option('-C, --no-liveCSS', 'disable liveCSS')\n  .option('-I, --no-liveImg', 'disable liveImg');\n\nprogram.on('include', function(val) {\n  program.filter.splice(program.filter.length - defaultValues.filter.length, 0,\n    {type: 'include', pattern: val});\n});\nprogram.on('exclude', function(val) {\n  program.filter.splice(program.filter.length - defaultValues.filter.length, 0,\n    {type: 'exclude', pattern: val});\n});\n\nfunction copyValues(dst, src) {\n  for (var key in defaultValues) {\n    // deep copy\n    dst[key] = JSON.parse(JSON.stringify(src[key]));\n  }\n  return dst;\n}\n\nvar validate = exports.validate = function(conf) {\n  for (var key in conf) {\n    if (!(key in defaultValues)) {\n      throw \"Invalid key: \" + key;\n    }\n    if (typeof defaultValues[key] !== typeof conf[key]) {\n      throw \"Invalid type: \" + key + \" should be \" + typeof defaultValues[key];\n    }\n    if (typeof conf[key] === 'number' && isNaN(conf[key])) {\n      throw \"Invalid value: \" + key + \" should be a number\";\n    }\n\n    if (conf.static && conf.proxy !== '') {\n      throw 'The \"static\" option cannot be specified together with \"proxy\" option';\n    }\n    if (conf.preferLocal && conf.proxy === '') {\n      throw 'The \"prefer-local\" option must be specified with \"proxy\" option';\n    }\n  }\n  return conf;\n};\n\nvar parseArgv = exports.parseArgv = function(argv) {\n  // set default value\n  copyValues(program, defaultValues);\n\n  // HACK: avoid commander.js's bug\n  // (https://github.com/visionmedia/commander.js/pull/121)\n  // program.parse() doesn't fail when unknown option and args are given.\n  // So we call program.parseOptions() instead of program.parse().\n  program._name = 'livereloadx';\n  var parsed = program.parseOptions(program.normalize(argv.slice(2)));\n  program.args = parsed.args;\n\n  // handle unknown options\n  if (parsed.unknown.length > 0) {\n    program.parseArgs([], parsed.unknown);\n  }\n\n  // handle <dir>\n  if (program.args.length === 1) {\n    program.dir = program.args[0];\n  } else if (program.args.length === 0) {\n    program.dir = '.';\n  } else if (program.args.length > 1) {\n    throw \"Too much arguments\";\n  }\n\n  // delete include and exclude\n  delete program.include;\n  delete program.exclude;\n\n  // copy program to Object\n  return validate(copyValues({}, program));\n};\n\nvar setDefaultValue = exports.setDefaultValue = function(conf) {\n  for (var key in defaultValues) {\n    if (!(key in conf)) {\n      // deep copy\n      conf[key] = JSON.parse(JSON.stringify(defaultValues[key]));\n    }\n  }\n  return validate(conf);\n};\n\nvar dump = exports.dump = function(log, conf) {\n  log('Config:');\n  log('  - mode:   %s', conf.static ? 'static' : conf.proxy !== '' ? 'proxy' : 'default');\n  if (conf.proxy) {\n    log('    url:  %s', conf.proxy);\n    log('    prefer local: %s', conf.preferLocal ? 'ON' : 'OFF');\n  }\n  log('  - port:   %d', conf.port);\n  log('  - filter:');\n  conf.filter.forEach(function(filter, i) {\n    log('    %d: %s \"%s\"', i + 1, filter.type, filter.pattern);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-livereloadx/node_modules/livereloadx/lib/filter.js":"\"use strict\";\n\nvar log = require('./log')('filter')\n  , minimatch = require('minimatch');\n\n/**\n * Iniialize a new `Filter` class with given filter\n *\n * @param {Object} filter filter which has `pattern` and `type` property\n */\nfunction Filter(filter) {\n  // validate type\n  if (filter.type !== 'include' && filter.type !== 'exclude') {\n    throw new Error('Invalid filter type: ' + filter.type);\n  }\n\n  this.pattern = filter.pattern;\n  this.type = filter.type;\n  this.is_include = (filter.type === 'include');\n  this.is_exclude = !this.is_include;\n  this.parse();\n}\n\nFilter.prototype.parse = function() {\n  // create RegExp with minimatch\n  // (ex) foo -> /^foo$/\n  var minimatchRe = minimatch.makeRe(this.pattern, {\n    dot: true, noext: true, nonegate: true\n  });\n  if (minimatchRe === false) {\n    throw new Error('Invalid pattern: ' + this.pattern);\n  }\n\n  // validate the returned RegExp\n  var source = minimatchRe.source;\n  if (!source.match(/^\\^.*\\$$/)) {\n    throw new Error('Unexpected regexp: \"' + this.pattern + '\" -> '  + source);\n  }\n\n  // change to fit the rsync filtering rules\n  // /^xxxx$/ -> /\\/(xxxx)$/\n  this.re = new RegExp('/(' + source.substr(1, source.length - 2) + ')$');\n  log.debug('re: %s', this.re.source);\n};\n\n/**\n * Check if `file` matches the filter\n *\n * @param {String] file\n * @param {Boolean} is_dir specify whether `file` is a directory\n * @return {Boolean} Match or not\n */\nFilter.prototype.match = function(file, is_dir) {\n  file = '//' + file;\n  return this.re.test(file) || is_dir && this.re.test(file + '/') || false;\n};\n\n\n/**\n * Return a filtering function with the given `filters`.\n *\n * @param {Array} filters  include or exclude filter.\n *                          (ex) `{ source: '*.js', is_include: true }`\n * @return {Function} filtering function which returns the given pattern is included\n *                    or not.\n */\nfunction getMatcher(filters) {\n  filters = filters.map(function(f) { return new Filter(f); });\n\n  return function match(file) {\n    var dirs = file.split('/');\n    log.trace('%s: filtering start', file);\n    for (var i = 0, len = dirs.length; i < len; i++) {\n      var name = dirs.slice(0, i + 1).join('/')\n        , is_dir = (i < len - 1);\n\n      for (var j = 0, filterLen = filters.length; j < filterLen; j++) {\n        if (filters[j].match(name, is_dir)) {\n          if (filters[j].is_include) {\n            log.trace('%s: include filter %d matches (%s)', name, j, filters[j].re.source);\n            break;\n          } else {\n            log.trace('%s: exclude filter %d matches (%s)', name, j, filters[j].re.source);\n            return false;\n          }\n        }\n      }\n      if (j === filterLen) {\n        log.trace('%s: no filter matches', name);\n      }\n    }\n    log.trace('%s: included', file);\n    return true;\n  };\n}\n\nmodule.exports.getMatcher = getMatcher;\nmodule.exports.Filter = Filter;\n","/home/travis/build/npmtest/node-npmtest-livereloadx/node_modules/livereloadx/contrib/livereload.js":"(function() {\nvar __customevents = {}, __protocol = {}, __connector = {}, __timer = {}, __options = {}, __reloader = {}, __livereload = {}, __less = {}, __startup = {};\n\n// customevents\nvar CustomEvents;\nCustomEvents = {\n  bind: function(element, eventName, handler) {\n    if (element.addEventListener) {\n      return element.addEventListener(eventName, handler, false);\n    } else if (element.attachEvent) {\n      element[eventName] = 1;\n      return element.attachEvent('onpropertychange', function(event) {\n        if (event.propertyName === eventName) {\n          return handler();\n        }\n      });\n    } else {\n      throw new Error(\"Attempt to attach custom event \" + eventName + \" to something which isn't a DOMElement\");\n    }\n  },\n  fire: function(element, eventName) {\n    var event;\n    if (element.addEventListener) {\n      event = document.createEvent('HTMLEvents');\n      event.initEvent(eventName, true, true);\n      return document.dispatchEvent(event);\n    } else if (element.attachEvent) {\n      if (element[eventName]) {\n        return element[eventName]++;\n      }\n    } else {\n      throw new Error(\"Attempt to fire custom event \" + eventName + \" on something which isn't a DOMElement\");\n    }\n  }\n};\n__customevents.bind = CustomEvents.bind;\n__customevents.fire = CustomEvents.fire;\n\n// protocol\nvar PROTOCOL_6, PROTOCOL_7, Parser, ProtocolError;\nvar __indexOf = Array.prototype.indexOf || function(item) {\n  for (var i = 0, l = this.length; i < l; i++) {\n    if (this[i] === item) return i;\n  }\n  return -1;\n};\n__protocol.PROTOCOL_6 = PROTOCOL_6 = 'http://livereload.com/protocols/official-6';\n__protocol.PROTOCOL_7 = PROTOCOL_7 = 'http://livereload.com/protocols/official-7';\n__protocol.ProtocolError = ProtocolError = (function() {\n  function ProtocolError(reason, data) {\n    this.message = \"LiveReload protocol error (\" + reason + \") after receiving data: \\\"\" + data + \"\\\".\";\n  }\n  return ProtocolError;\n})();\n__protocol.Parser = Parser = (function() {\n  function Parser(handlers) {\n    this.handlers = handlers;\n    this.reset();\n  }\n  Parser.prototype.reset = function() {\n    return this.protocol = null;\n  };\n  Parser.prototype.process = function(data) {\n    var command, message, options, _ref;\n    try {\n      if (!(this.protocol != null)) {\n        if (data.match(/^!!ver:([\\d.]+)$/)) {\n          this.protocol = 6;\n        } else if (message = this._parseMessage(data, ['hello'])) {\n          if (!message.protocols.length) {\n            throw new ProtocolError(\"no protocols specified in handshake message\");\n          } else if (__indexOf.call(message.protocols, PROTOCOL_7) >= 0) {\n            this.protocol = 7;\n          } else if (__indexOf.call(message.protocols, PROTOCOL_6) >= 0) {\n            this.protocol = 6;\n          } else {\n            throw new ProtocolError(\"no supported protocols found\");\n          }\n        }\n        return this.handlers.connected(this.protocol);\n      } else if (this.protocol === 6) {\n        message = JSON.parse(data);\n        if (!message.length) {\n          throw new ProtocolError(\"protocol 6 messages must be arrays\");\n        }\n        command = message[0], options = message[1];\n        if (command !== 'refresh') {\n          throw new ProtocolError(\"unknown protocol 6 command\");\n        }\n        return this.handlers.message({\n          command: 'reload',\n          path: options.path,\n          liveCSS: (_ref = options.apply_css_live) != null ? _ref : true\n        });\n      } else {\n        message = this._parseMessage(data, ['reload', 'alert']);\n        return this.handlers.message(message);\n      }\n    } catch (e) {\n      if (e instanceof ProtocolError) {\n        return this.handlers.error(e);\n      } else {\n        throw e;\n      }\n    }\n  };\n  Parser.prototype._parseMessage = function(data, validCommands) {\n    var message, _ref;\n    try {\n      message = JSON.parse(data);\n    } catch (e) {\n      throw new ProtocolError('unparsable JSON', data);\n    }\n    if (!message.command) {\n      throw new ProtocolError('missing \"command\" key', data);\n    }\n    if (_ref = message.command, __indexOf.call(validCommands, _ref) < 0) {\n      throw new ProtocolError(\"invalid command '\" + message.command + \"', only valid commands are: \" + (validCommands.join(', ')) + \")\", data);\n    }\n    return message;\n  };\n  return Parser;\n})();\n\n// connector\n// Generated by CoffeeScript 1.3.3\nvar Connector, PROTOCOL_6, PROTOCOL_7, Parser, Version, _ref;\n\n_ref = __protocol, Parser = _ref.Parser, PROTOCOL_6 = _ref.PROTOCOL_6, PROTOCOL_7 = _ref.PROTOCOL_7;\n\nVersion = '2.0.8';\n\n__connector.Connector = Connector = (function() {\n\n  function Connector(options, WebSocket, Timer, handlers) {\n    var _this = this;\n    this.options = options;\n    this.WebSocket = WebSocket;\n    this.Timer = Timer;\n    this.handlers = handlers;\n    this._uri = \"ws://\" + this.options.host + \":\" + this.options.port + \"/livereload\";\n    this._nextDelay = this.options.mindelay;\n    this._connectionDesired = false;\n    this.protocol = 0;\n    this.protocolParser = new Parser({\n      connected: function(protocol) {\n        _this.protocol = protocol;\n        _this._handshakeTimeout.stop();\n        _this._nextDelay = _this.options.mindelay;\n        _this._disconnectionReason = 'broken';\n        return _this.handlers.connected(protocol);\n      },\n      error: function(e) {\n        _this.handlers.error(e);\n        return _this._closeOnError();\n      },\n      message: function(message) {\n        return _this.handlers.message(message);\n      }\n    });\n    this._handshakeTimeout = new Timer(function() {\n      if (!_this._isSocketConnected()) {\n        return;\n      }\n      _this._disconnectionReason = 'handshake-timeout';\n      return _this.socket.close();\n    });\n    this._reconnectTimer = new Timer(function() {\n      if (!_this._connectionDesired) {\n        return;\n      }\n      return _this.connect();\n    });\n    this.connect();\n  }\n\n  Connector.prototype._isSocketConnected = function() {\n    return this.socket && this.socket.readyState === this.WebSocket.OPEN;\n  };\n\n  Connector.prototype.connect = function() {\n    var _this = this;\n    this._connectionDesired = true;\n    if (this._isSocketConnected()) {\n      return;\n    }\n    this._reconnectTimer.stop();\n    this._disconnectionReason = 'cannot-connect';\n    this.protocolParser.reset();\n    this.handlers.connecting();\n    this.socket = new this.WebSocket(this._uri);\n    this.socket.onopen = function(e) {\n      return _this._onopen(e);\n    };\n    this.socket.onclose = function(e) {\n      return _this._onclose(e);\n    };\n    this.socket.onmessage = function(e) {\n      return _this._onmessage(e);\n    };\n    return this.socket.onerror = function(e) {\n      return _this._onerror(e);\n    };\n  };\n\n  Connector.prototype.disconnect = function() {\n    this._connectionDesired = false;\n    this._reconnectTimer.stop();\n    if (!this._isSocketConnected()) {\n      return;\n    }\n    this._disconnectionReason = 'manual';\n    return this.socket.close();\n  };\n\n  Connector.prototype._scheduleReconnection = function() {\n    if (!this._connectionDesired) {\n      return;\n    }\n    if (!this._reconnectTimer.running) {\n      this._reconnectTimer.start(this._nextDelay);\n      return this._nextDelay = Math.min(this.options.maxdelay, this._nextDelay * 2);\n    }\n  };\n\n  Connector.prototype.sendCommand = function(command) {\n    if (this.protocol == null) {\n      return;\n    }\n    return this._sendCommand(command);\n  };\n\n  Connector.prototype._sendCommand = function(command) {\n    return this.socket.send(JSON.stringify(command));\n  };\n\n  Connector.prototype._closeOnError = function() {\n    this._handshakeTimeout.stop();\n    this._disconnectionReason = 'error';\n    return this.socket.close();\n  };\n\n  Connector.prototype._onopen = function(e) {\n    var hello;\n    this.handlers.socketConnected();\n    this._disconnectionReason = 'handshake-failed';\n    hello = {\n      command: 'hello',\n      protocols: [PROTOCOL_6, PROTOCOL_7]\n    };\n    hello.ver = Version;\n    if (this.options.ext) {\n      hello.ext = this.options.ext;\n    }\n    if (this.options.extver) {\n      hello.extver = this.options.extver;\n    }\n    if (this.options.snipver) {\n      hello.snipver = this.options.snipver;\n    }\n    this._sendCommand(hello);\n    return this._handshakeTimeout.start(this.options.handshake_timeout);\n  };\n\n  Connector.prototype._onclose = function(e) {\n    this.protocol = 0;\n    this.handlers.disconnected(this._disconnectionReason, this._nextDelay);\n    return this._scheduleReconnection();\n  };\n\n  Connector.prototype._onerror = function(e) {};\n\n  Connector.prototype._onmessage = function(e) {\n    return this.protocolParser.process(e.data);\n  };\n\n  return Connector;\n\n})();\n\n// timer\nvar Timer;\nvar __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n__timer.Timer = Timer = (function() {\n  function Timer(func) {\n    this.func = func;\n    this.running = false;\n    this.id = null;\n    this._handler = __bind(function() {\n      this.running = false;\n      this.id = null;\n      return this.func();\n    }, this);\n  }\n  Timer.prototype.start = function(timeout) {\n    if (this.running) {\n      clearTimeout(this.id);\n    }\n    this.id = setTimeout(this._handler, timeout);\n    return this.running = true;\n  };\n  Timer.prototype.stop = function() {\n    if (this.running) {\n      clearTimeout(this.id);\n      this.running = false;\n      return this.id = null;\n    }\n  };\n  return Timer;\n})();\nTimer.start = function(timeout, func) {\n  return setTimeout(func, timeout);\n};\n\n// options\nvar Options;\n__options.Options = Options = (function() {\n  function Options() {\n    this.host = null;\n    this.port = 35729;\n    this.snipver = null;\n    this.ext = null;\n    this.extver = null;\n    this.mindelay = 1000;\n    this.maxdelay = 60000;\n    this.handshake_timeout = 5000;\n  }\n  Options.prototype.set = function(name, value) {\n    switch (typeof this[name]) {\n      case 'undefined':\n        break;\n      case 'number':\n        return this[name] = +value;\n      default:\n        return this[name] = value;\n    }\n  };\n  return Options;\n})();\nOptions.extract = function(document) {\n  var element, keyAndValue, m, mm, options, pair, src, _i, _j, _len, _len2, _ref, _ref2;\n  _ref = document.getElementsByTagName('script');\n  for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n    element = _ref[_i];\n    if ((src = element.src) && (m = src.match(/^[^:]+:\\/\\/(.*)\\/z?livereload\\.js(?:\\?(.*))?$/))) {\n      options = new Options();\n      if (mm = m[1].match(/^([^\\/:]+)(?::(\\d+))?$/)) {\n        options.host = mm[1];\n        if (mm[2]) {\n          options.port = parseInt(mm[2], 10);\n        }\n      }\n      if (m[2]) {\n        _ref2 = m[2].split('&');\n        for (_j = 0, _len2 = _ref2.length; _j < _len2; _j++) {\n          pair = _ref2[_j];\n          if ((keyAndValue = pair.split('=')).length > 1) {\n            options.set(keyAndValue[0].replace(/-/g, '_'), keyAndValue.slice(1).join('='));\n          }\n        }\n      }\n      return options;\n    }\n  }\n  return null;\n};\n\n// reloader\n// Generated by CoffeeScript 1.3.1\n(function() {\n  var IMAGE_STYLES, Reloader, numberOfMatchingSegments, pathFromUrl, pathsMatch, pickBestMatch, splitUrl;\n\n  splitUrl = function(url) {\n    var hash, index, params;\n    if ((index = url.indexOf('#')) >= 0) {\n      hash = url.slice(index);\n      url = url.slice(0, index);\n    } else {\n      hash = '';\n    }\n    if ((index = url.indexOf('?')) >= 0) {\n      params = url.slice(index);\n      url = url.slice(0, index);\n    } else {\n      params = '';\n    }\n    return {\n      url: url,\n      params: params,\n      hash: hash\n    };\n  };\n\n  pathFromUrl = function(url) {\n    var path;\n    url = splitUrl(url).url;\n    if (url.indexOf('file://') === 0) {\n      path = url.replace(/^file:\\/\\/(localhost)?/, '');\n    } else {\n      path = url.replace(/^([^:]+:)?\\/\\/([^:\\/]+)(:\\d*)?\\//, '/');\n    }\n    return decodeURIComponent(path);\n  };\n\n  pickBestMatch = function(path, objects, pathFunc) {\n    var bestMatch, object, score, _i, _len;\n    bestMatch = {\n      score: 0\n    };\n    for (_i = 0, _len = objects.length; _i < _len; _i++) {\n      object = objects[_i];\n      score = numberOfMatchingSegments(path, pathFunc(object));\n      if (score > bestMatch.score) {\n        bestMatch = {\n          object: object,\n          score: score\n        };\n      }\n    }\n    if (bestMatch.score > 0) {\n      return bestMatch;\n    } else {\n      return null;\n    }\n  };\n\n  numberOfMatchingSegments = function(path1, path2) {\n    var comps1, comps2, eqCount, len;\n    path1 = path1.replace(/^\\/+/, '').toLowerCase();\n    path2 = path2.replace(/^\\/+/, '').toLowerCase();\n    if (path1 === path2) {\n      return 10000;\n    }\n    comps1 = path1.split('/').reverse();\n    comps2 = path2.split('/').reverse();\n    len = Math.min(comps1.length, comps2.length);\n    eqCount = 0;\n    while (eqCount < len && comps1[eqCount] === comps2[eqCount]) {\n      ++eqCount;\n    }\n    return eqCount;\n  };\n\n  pathsMatch = function(path1, path2) {\n    return numberOfMatchingSegments(path1, path2) > 0;\n  };\n\n  IMAGE_STYLES = [\n    {\n      selector: 'background',\n      styleNames: ['backgroundImage']\n    }, {\n      selector: 'border',\n      styleNames: ['borderImage', 'webkitBorderImage', 'MozBorderImage']\n    }\n  ];\n\n  __reloader.Reloader = Reloader = (function() {\n\n    Reloader.name = 'Reloader';\n\n    function Reloader(window, console, Timer) {\n      this.window = window;\n      this.console = console;\n      this.Timer = Timer;\n      this.document = this.window.document;\n      this.importCacheWaitPeriod = 200;\n      this.plugins = [];\n    }\n\n    Reloader.prototype.addPlugin = function(plugin) {\n      return this.plugins.push(plugin);\n    };\n\n    Reloader.prototype.analyze = function(callback) {\n      return results;\n    };\n\n    Reloader.prototype.reload = function(path, options) {\n      var plugin, _base, _i, _len, _ref;\n      this.options = options;\n      if ((_base = this.options).stylesheetReloadTimeout == null) {\n        _base.stylesheetReloadTimeout = 15000;\n      }\n      _ref = this.plugins;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        plugin = _ref[_i];\n        if (plugin.reload && plugin.reload(path, options)) {\n          return;\n        }\n      }\n      if (options.liveCSS) {\n        if (path.match(/\\.css$/i)) {\n          if (this.reloadStylesheet(path)) {\n            return;\n          }\n        }\n      }\n      if (options.liveImg) {\n        if (path.match(/\\.(jpe?g|png|gif)$/i)) {\n          this.reloadImages(path);\n          return;\n        }\n      }\n      return this.reloadPage();\n    };\n\n    Reloader.prototype.reloadPage = function() {\n      return this.window.document.location.reload();\n    };\n\n    Reloader.prototype.reloadImages = function(path) {\n      var expando, img, selector, styleNames, styleSheet, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _results;\n      expando = this.generateUniqueString();\n      _ref = this.document.images;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        img = _ref[_i];\n        if (pathsMatch(path, pathFromUrl(img.src))) {\n          img.src = this.generateCacheBustUrl(img.src, expando);\n        }\n      }\n      if (this.document.querySelectorAll) {\n        for (_j = 0, _len1 = IMAGE_STYLES.length; _j < _len1; _j++) {\n          _ref1 = IMAGE_STYLES[_j], selector = _ref1.selector, styleNames = _ref1.styleNames;\n          _ref2 = this.document.querySelectorAll(\"[style*=\" + selector + \"]\");\n          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {\n            img = _ref2[_k];\n            this.reloadStyleImages(img.style, styleNames, path, expando);\n          }\n        }\n      }\n      if (this.document.styleSheets) {\n        _ref3 = this.document.styleSheets;\n        _results = [];\n        for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {\n          styleSheet = _ref3[_l];\n          _results.push(this.reloadStylesheetImages(styleSheet, path, expando));\n        }\n        return _results;\n      }\n    };\n\n    Reloader.prototype.reloadStylesheetImages = function(styleSheet, path, expando) {\n      var rule, rules, styleNames, _i, _j, _len, _len1;\n      try {\n        rules = styleSheet != null ? styleSheet.cssRules : void 0;\n      } catch (e) {\n\n      }\n      if (!rules) {\n        return;\n      }\n      for (_i = 0, _len = rules.length; _i < _len; _i++) {\n        rule = rules[_i];\n        switch (rule.type) {\n          case CSSRule.IMPORT_RULE:\n            this.reloadStylesheetImages(rule.styleSheet, path, expando);\n            break;\n          case CSSRule.STYLE_RULE:\n            for (_j = 0, _len1 = IMAGE_STYLES.length; _j < _len1; _j++) {\n              styleNames = IMAGE_STYLES[_j].styleNames;\n              this.reloadStyleImages(rule.style, styleNames, path, expando);\n            }\n            break;\n          case CSSRule.MEDIA_RULE:\n            this.reloadStylesheetImages(rule, path, expando);\n        }\n      }\n    };\n\n    Reloader.prototype.reloadStyleImages = function(style, styleNames, path, expando) {\n      var newValue, styleName, value, _i, _len,\n        _this = this;\n      for (_i = 0, _len = styleNames.length; _i < _len; _i++) {\n        styleName = styleNames[_i];\n        value = style[styleName];\n        if (typeof value === 'string') {\n          newValue = value.replace(/\\burl\\s*\\(([^)]*)\\)/, function(match, src) {\n            if (pathsMatch(path, pathFromUrl(src))) {\n              return \"url(\" + (_this.generateCacheBustUrl(src, expando)) + \")\";\n            } else {\n              return match;\n            }\n          });\n          if (newValue !== value) {\n            style[styleName] = newValue;\n          }\n        }\n      }\n    };\n\n    Reloader.prototype.reloadStylesheet = function(path) {\n      var imported, link, links, match, style, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1,\n        _this = this;\n      links = (function() {\n        var _i, _len, _ref, _results;\n        _ref = this.document.getElementsByTagName('link');\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          link = _ref[_i];\n          if (link.rel === 'stylesheet' && !link.__LiveReload_pendingRemoval) {\n            _results.push(link);\n          }\n        }\n        return _results;\n      }).call(this);\n      imported = [];\n      _ref = this.document.getElementsByTagName('style');\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        style = _ref[_i];\n        if (style.sheet) {\n          this.collectImportedStylesheets(style, style.sheet, imported);\n        }\n      }\n      for (_j = 0, _len1 = links.length; _j < _len1; _j++) {\n        link = links[_j];\n        this.collectImportedStylesheets(link, link.sheet, imported);\n      }\n      if (this.window.StyleFix && this.document.querySelectorAll) {\n        _ref1 = this.document.querySelectorAll('style[data-href]');\n        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {\n          style = _ref1[_k];\n          links.push(style);\n        }\n      }\n      this.console.log(\"LiveReload found \" + links.length + \" LINKed stylesheets, \" + imported.length + \" @imported stylesheets\");\n      match = pickBestMatch(path, links.concat(imported), function(l) {\n        return pathFromUrl(_this.linkHref(l));\n      });\n      if (match) {\n        if (match.object.rule) {\n          this.console.log(\"LiveReload is reloading imported stylesheet: \" + match.object.href);\n          this.reattachImportedRule(match.object);\n        } else {\n          this.console.log(\"LiveReload is reloading stylesheet: \" + (this.linkHref(match.object)));\n          this.reattachStylesheetLink(match.object);\n        }\n      } else {\n        this.console.log(\"LiveReload will reload all stylesheets because path '\" + path + \"' did not match any specific one\");\n        for (_l = 0, _len3 = links.length; _l < _len3; _l++) {\n          link = links[_l];\n          this.reattachStylesheetLink(link);\n        }\n      }\n      return true;\n    };\n\n    Reloader.prototype.collectImportedStylesheets = function(link, styleSheet, result) {\n      var index, rule, rules, _i, _len;\n      try {\n        rules = styleSheet != null ? styleSheet.cssRules : void 0;\n      } catch (e) {\n\n      }\n      if (rules && rules.length) {\n        for (index = _i = 0, _len = rules.length; _i < _len; index = ++_i) {\n          rule = rules[index];\n          switch (rule.type) {\n            case CSSRule.CHARSET_RULE:\n              continue;\n            case CSSRule.IMPORT_RULE:\n              result.push({\n                link: link,\n                rule: rule,\n                index: index,\n                href: rule.href\n              });\n              this.collectImportedStylesheets(link, rule.styleSheet, result);\n              break;\n            default:\n              break;\n          }\n        }\n      }\n    };\n\n    Reloader.prototype.waitUntilCssLoads = function(clone, func) {\n      var callbackExecuted, executeCallback, poll,\n        _this = this;\n      callbackExecuted = false;\n      executeCallback = function() {\n        if (callbackExecuted) {\n          return;\n        }\n        callbackExecuted = true;\n        return func();\n      };\n      clone.onload = function() {\n        console.log(\"onload!\");\n        _this.knownToSupportCssOnLoad = true;\n        return executeCallback();\n      };\n      if (!this.knownToSupportCssOnLoad) {\n        (poll = function() {\n          if (clone.sheet) {\n            console.log(\"polling!\");\n            return executeCallback();\n          } else {\n            return _this.Timer.start(50, poll);\n          }\n        })();\n      }\n      return this.Timer.start(this.options.stylesheetReloadTimeout, executeCallback);\n    };\n\n    Reloader.prototype.linkHref = function(link) {\n      return link.href || link.getAttribute('data-href');\n    };\n\n    Reloader.prototype.reattachStylesheetLink = function(link) {\n      var clone, parent,\n        _this = this;\n      if (link.__LiveReload_pendingRemoval) {\n        return;\n      }\n      link.__LiveReload_pendingRemoval = true;\n      if (link.tagName === 'STYLE') {\n        clone = this.document.createElement('link');\n        clone.rel = 'stylesheet';\n        clone.media = link.media;\n        clone.disabled = link.disabled;\n      } else {\n        clone = link.cloneNode(false);\n      }\n      clone.href = this.generateCacheBustUrl(this.linkHref(link));\n      parent = link.parentNode;\n      if (parent.lastChild === link) {\n        parent.appendChild(clone);\n      } else {\n        parent.insertBefore(clone, link.nextSibling);\n      }\n      return this.waitUntilCssLoads(clone, function() {\n        var additionalWaitingTime;\n        if (/AppleWebKit/.test(navigator.userAgent)) {\n          additionalWaitingTime = 5;\n        } else {\n          additionalWaitingTime = 200;\n        }\n        return _this.Timer.start(additionalWaitingTime, function() {\n          var _ref;\n          if (!link.parentNode) {\n            return;\n          }\n          link.parentNode.removeChild(link);\n          clone.onreadystatechange = null;\n          return (_ref = _this.window.StyleFix) != null ? _ref.link(clone) : void 0;\n        });\n      });\n    };\n\n    Reloader.prototype.reattachImportedRule = function(_arg) {\n      var href, index, link, media, newRule, parent, rule, tempLink,\n        _this = this;\n      rule = _arg.rule, index = _arg.index, link = _arg.link;\n      parent = rule.parentStyleSheet;\n      href = this.generateCacheBustUrl(rule.href);\n      media = rule.media.length ? [].join.call(rule.media, ', ') : '';\n      newRule = \"@import url(\\\"\" + href + \"\\\") \" + media + \";\";\n      rule.__LiveReload_newHref = href;\n      tempLink = this.document.createElement(\"link\");\n      tempLink.rel = 'stylesheet';\n      tempLink.href = href;\n      tempLink.__LiveReload_pendingRemoval = true;\n      if (link.parentNode) {\n        link.parentNode.insertBefore(tempLink, link);\n      }\n      return this.Timer.start(this.importCacheWaitPeriod, function() {\n        if (tempLink.parentNode) {\n          tempLink.parentNode.removeChild(tempLink);\n        }\n        if (rule.__LiveReload_newHref !== href) {\n          return;\n        }\n        parent.insertRule(newRule, index);\n        parent.deleteRule(index + 1);\n        rule = parent.cssRules[index];\n        rule.__LiveReload_newHref = href;\n        return _this.Timer.start(_this.importCacheWaitPeriod, function() {\n          if (rule.__LiveReload_newHref !== href) {\n            return;\n          }\n          parent.insertRule(newRule, index);\n          return parent.deleteRule(index + 1);\n        });\n      });\n    };\n\n    Reloader.prototype.generateUniqueString = function() {\n      return 'livereload=' + Date.now();\n    };\n\n    Reloader.prototype.generateCacheBustUrl = function(url, expando) {\n      var hash, oldParams, params, _ref;\n      if (expando == null) {\n        expando = this.generateUniqueString();\n      }\n      _ref = splitUrl(url), url = _ref.url, hash = _ref.hash, oldParams = _ref.params;\n      if (this.options.overrideURL) {\n        if (url.indexOf(this.options.serverURL) < 0) {\n          url = this.options.serverURL + this.options.overrideURL + \"?url=\" + encodeURIComponent(url);\n        }\n      }\n      params = oldParams.replace(/(\\?|&)livereload=(\\d+)/, function(match, sep) {\n        return \"\" + sep + expando;\n      });\n      if (params === oldParams) {\n        if (oldParams.length === 0) {\n          params = \"?\" + expando;\n        } else {\n          params = \"\" + oldParams + \"&\" + expando;\n        }\n      }\n      return url + params + hash;\n    };\n\n    return Reloader;\n\n  })();\n\n}).call(this);\n\n// livereload\nvar Connector, LiveReload, Options, Reloader, Timer;\n\nConnector = __connector.Connector;\n\nTimer = __timer.Timer;\n\nOptions = __options.Options;\n\nReloader = __reloader.Reloader;\n\n__livereload.LiveReload = LiveReload = (function() {\n\n  function LiveReload(window) {\n    var _this = this;\n    this.window = window;\n    this.listeners = {};\n    this.plugins = [];\n    this.pluginIdentifiers = {};\n    this.console = this.window.location.href.match(/LR-verbose/) && this.window.console && this.window.console.log && this.window.console.error ? this.window.console : {\n      log: function() {},\n      error: function() {}\n    };\n    if (!(this.WebSocket = this.window.WebSocket || this.window.MozWebSocket)) {\n      console.error(\"LiveReload disabled because the browser does not seem to support web sockets\");\n      return;\n    }\n    if (!(this.options = Options.extract(this.window.document))) {\n      console.error(\"LiveReload disabled because it could not find its own <SCRIPT> tag\");\n      return;\n    }\n    this.reloader = new Reloader(this.window, this.console, Timer);\n    this.connector = new Connector(this.options, this.WebSocket, Timer, {\n      connecting: function() {},\n      socketConnected: function() {},\n      connected: function(protocol) {\n        var _base;\n        if (typeof (_base = _this.listeners).connect === \"function\") {\n          _base.connect();\n        }\n        _this.log(\"LiveReload is connected to \" + _this.options.host + \":\" + _this.options.port + \" (protocol v\" + protocol + \").\");\n        return _this.analyze();\n      },\n      error: function(e) {\n        if (e instanceof ProtocolError) {\n          return console.log(\"\" + e.message + \".\");\n        } else {\n          return console.log(\"LiveReload internal error: \" + e.message);\n        }\n      },\n      disconnected: function(reason, nextDelay) {\n        var _base;\n        if (typeof (_base = _this.listeners).disconnect === \"function\") {\n          _base.disconnect();\n        }\n        switch (reason) {\n          case 'cannot-connect':\n            return _this.log(\"LiveReload cannot connect to \" + _this.options.host + \":\" + _this.options.port + \", will retry in \" + nextDelay + \" sec.\");\n          case 'broken':\n            return _this.log(\"LiveReload disconnected from \" + _this.options.host + \":\" + _this.options.port + \", reconnecting in \" + nextDelay + \" sec.\");\n          case 'handshake-timeout':\n            return _this.log(\"LiveReload cannot connect to \" + _this.options.host + \":\" + _this.options.port + \" (handshake timeout), will retry in \" + nextDelay + \" sec.\");\n          case 'handshake-failed':\n            return _this.log(\"LiveReload cannot connect to \" + _this.options.host + \":\" + _this.options.port + \" (handshake failed), will retry in \" + nextDelay + \" sec.\");\n          case 'manual':\n            break;\n          case 'error':\n            break;\n          default:\n            return _this.log(\"LiveReload disconnected from \" + _this.options.host + \":\" + _this.options.port + \" (\" + reason + \"), reconnecting in \" + nextDelay + \" sec.\");\n        }\n      },\n      message: function(message) {\n        switch (message.command) {\n          case 'reload':\n            return _this.performReload(message);\n          case 'alert':\n            return _this.performAlert(message);\n        }\n      }\n    });\n  }\n\n  LiveReload.prototype.on = function(eventName, handler) {\n    return this.listeners[eventName] = handler;\n  };\n\n  LiveReload.prototype.log = function(message) {\n    return this.console.log(\"\" + message);\n  };\n\n  LiveReload.prototype.performReload = function(message) {\n    var _ref, _ref2;\n    this.log(\"LiveReload received reload request for \" + message.path + \".\");\n    return this.reloader.reload(message.path, {\n      liveCSS: (_ref = message.liveCSS) != null ? _ref : true,\n      liveImg: (_ref2 = message.liveImg) != null ? _ref2 : true,\n      originalPath: message.originalPath || '',\n      overrideURL: message.overrideURL || '',\n      serverURL: \"http://\" + this.options.host + \":\" + this.options.port\n    });\n  };\n\n  LiveReload.prototype.performAlert = function(message) {\n    return alert(message.message);\n  };\n\n  LiveReload.prototype.shutDown = function() {\n    var _base;\n    this.connector.disconnect();\n    this.log(\"LiveReload disconnected.\");\n    return typeof (_base = this.listeners).shutdown === \"function\" ? _base.shutdown() : void 0;\n  };\n\n  LiveReload.prototype.hasPlugin = function(identifier) {\n    return !!this.pluginIdentifiers[identifier];\n  };\n\n  LiveReload.prototype.addPlugin = function(pluginClass) {\n    var plugin;\n    var _this = this;\n    if (this.hasPlugin(pluginClass.identifier)) return;\n    this.pluginIdentifiers[pluginClass.identifier] = true;\n    plugin = new pluginClass(this.window, {\n      _livereload: this,\n      _reloader: this.reloader,\n      _connector: this.connector,\n      console: this.console,\n      Timer: Timer,\n      generateCacheBustUrl: function(url) {\n        return _this.reloader.generateCacheBustUrl(url);\n      }\n    });\n    this.plugins.push(plugin);\n    this.reloader.addPlugin(plugin);\n  };\n\n  LiveReload.prototype.analyze = function() {\n    var plugin, pluginData, pluginsData, _i, _len, _ref;\n    if (!(this.connector.protocol >= 7)) return;\n    pluginsData = {};\n    _ref = this.plugins;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      plugin = _ref[_i];\n      pluginsData[plugin.constructor.identifier] = pluginData = (typeof plugin.analyze === \"function\" ? plugin.analyze() : void 0) || {};\n      pluginData.version = plugin.constructor.version;\n    }\n    this.connector.sendCommand({\n      command: 'info',\n      plugins: pluginsData,\n      url: this.window.location.href\n    });\n  };\n\n  return LiveReload;\n\n})();\n\n// less\nvar LessPlugin;\n__less = LessPlugin = (function() {\n  LessPlugin.identifier = 'less';\n  LessPlugin.version = '1.0';\n  function LessPlugin(window, host) {\n    this.window = window;\n    this.host = host;\n  }\n  LessPlugin.prototype.reload = function(path, options) {\n    if (this.window.less && this.window.less.refresh) {\n      if (path.match(/\\.less$/i)) {\n        return this.reloadLess(path);\n      }\n      if (options.originalPath.match(/\\.less$/i)) {\n        return this.reloadLess(options.originalPath);\n      }\n    }\n    return false;\n  };\n  LessPlugin.prototype.reloadLess = function(path) {\n    var link, links, _i, _len;\n    links = (function() {\n      var _i, _len, _ref, _results;\n      _ref = document.getElementsByTagName('link');\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        link = _ref[_i];\n        if (link.href && link.rel === 'stylesheet/less' || (link.rel.match(/stylesheet/) && link.type.match(/^text\\/(x-)?less$/))) {\n          _results.push(link);\n        }\n      }\n      return _results;\n    })();\n    if (links.length === 0) {\n      return false;\n    }\n    for (_i = 0, _len = links.length; _i < _len; _i++) {\n      link = links[_i];\n      link.href = this.host.generateCacheBustUrl(link.href);\n    }\n    this.host.console.log(\"LiveReload is asking LESS to recompile all stylesheets\");\n    this.window.less.refresh(true);\n    return true;\n  };\n  LessPlugin.prototype.analyze = function() {\n    return {\n      disable: !!(this.window.less && this.window.less.refresh)\n    };\n  };\n  return LessPlugin;\n})();\n\n// startup\nvar CustomEvents, LiveReload, k;\nCustomEvents = __customevents;\nLiveReload = window.LiveReload = new (__livereload.LiveReload)(window);\nfor (k in window) {\n  if (k.match(/^LiveReloadPlugin/)) {\n    LiveReload.addPlugin(window[k]);\n  }\n}\nLiveReload.addPlugin(__less);\nLiveReload.on('shutdown', function() {\n  return delete window.LiveReload;\n});\nLiveReload.on('connect', function() {\n  return CustomEvents.fire(document, 'LiveReloadConnect');\n});\nLiveReload.on('disconnect', function() {\n  return CustomEvents.fire(document, 'LiveReloadDisconnect');\n});\nCustomEvents.bind(document, 'LiveReloadShutDown', function() {\n  return LiveReload.shutDown();\n});\n})();"}